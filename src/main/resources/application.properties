# =============================================================================
# STATUS MONITORING APPLICATION - CONFIGURATION PROPERTIES
# =============================================================================
# This file contains all configuration properties for the Status Monitoring
# application. Properties are organized by functional area.
#
# Environment-specific overrides can be placed in:
#   - application-dev.properties   (development)
#   - application-test.properties  (testing)
#   - application-prod.properties  (production)
#
# Properties can also be overridden via environment variables using the format:
#   SPRING_DATASOURCE_URL (replaces spring.dat  asource.url)
# =============================================================================

# -----------------------------------------------------------------------------
# APPLICATION IDENTITY
# -----------------------------------------------------------------------------
# The name of the Spring Boot application. Used for identification in logs,
# monitoring tools, and Spring Cloud service discovery.
spring.application.name=status

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
# PostgreSQL database connection settings. The application uses PostgreSQL
# as its primary data store for all tenant, organization, user, and monitoring
# data.

# JDBC connection URL for PostgreSQL
# Format: jdbc:postgresql://[host]:[port]/[database_name]
# Default PostgreSQL port is 5432
spring.datasource.url=jdbc:postgresql://localhost:5432/uptime

# Database authentication credentials
# WARNING: In production, use environment variables or a secrets manager
# instead of hardcoding credentials in this file.
spring.datasource.username=postgres
spring.datasource.password=Resume1.

# JDBC driver class for PostgreSQL
# This is typically auto-detected but explicitly set for clarity
spring.datasource.driver-class-name=org.postgresql.Driver

# =============================================================================
# JPA / HIBERNATE CONFIGURATION
# =============================================================================
# Java Persistence API settings for ORM (Object-Relational Mapping) behavior.
# Hibernate is the JPA implementation used by Spring Boot.

# Schema management strategy
# Options:
#   - none:        No schema management (recommended for production with Flyway)
#   - validate:    Validate schema matches entities (current setting - safe for production)
#   - update:      Update schema automatically (use with caution)
#   - create:      Create schema, destroying previous data
#   - create-drop: Create on startup, drop on shutdown (testing only)
spring.jpa.hibernate.ddl-auto=validate

# SQL logging toggle
# Set to 'true' to log all SQL statements to console (useful for debugging)
# WARNING: Enable only in development - generates significant log volume
spring.jpa.show-sql=false

# PostgreSQL-specific Hibernate dialect
# Enables PostgreSQL-specific SQL generation and optimizations
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Format SQL output for readability
# When show-sql is enabled, this formats queries with indentation and line breaks
spring.jpa.properties.hibernate.format_sql=true

# =============================================================================
# FLYWAY DATABASE MIGRATION
# =============================================================================
# Flyway handles database schema versioning and migrations. Migration scripts
# are executed automatically on application startup to keep the database
# schema synchronized with the application code.

# Location of migration scripts
# Scripts should be named: V{version}__{description}.sql
# Example: V1__create_users_table.sql, V2__add_tenant_column.sql
spring.flyway.locations=classpath:db/migration

# Baseline on migrate
# When 'true', Flyway will create a baseline version for existing databases
# that weren't previously managed by Flyway. This allows Flyway to manage
# databases that already have schema/data.
spring.flyway.baseline-on-migrate=true

# =============================================================================
# JWT (JSON Web Token) AUTHENTICATION
# =============================================================================
# JWT configuration for stateless API authentication. Tokens are used for
# both API access (Bearer tokens) and web session management (secure cookies).

# JWT signing secret key (Base64 encoded)
# SECURITY CRITICAL: This key is used to sign and verify all JWT tokens.
# Requirements:
#   - Must be Base64 encoded
#   - Should be at least 256 bits (32 bytes) for HS256 algorithm
#   - Must be kept secret and unique per environment
#   - In production, load from environment variable or secrets manager
# To generate a new key: echo -n "your-secret-key-here" | base64
jwt.secret=dGhpc2lzYXNlY3JldGtleWZvcmp3dGF1dGhlbnRpY2F0aW9uYW5kYXV0aG9yaXphdGlvbjEyMw==

# Access token expiration time in milliseconds
# Current value: 86400000ms = 24 hours
# Recommended values:
#   - API access: 15-60 minutes (900000-3600000)
#   - Web sessions: 1-24 hours (3600000-86400000)
jwt.expiration=86400000

# Refresh token expiration time in milliseconds
# Current value: 604800000ms = 7 days
# Refresh tokens allow obtaining new access tokens without re-authentication
# Should be significantly longer than access token expiration
jwt.refresh.expiration=604800000

# =============================================================================
# API DOCUMENTATION (OpenAPI / Swagger)
# =============================================================================
# SpringDoc OpenAPI configuration for automatic API documentation generation.
# Swagger UI provides an interactive interface for exploring and testing APIs.

# Swagger UI web interface
# When 'true', Swagger UI is available at /swagger-ui.html
# Disable in production for security
springdoc.swagger-ui.enabled=false

# OpenAPI specification endpoint
# When 'true', JSON/YAML spec available at /v3/api-docs
# Can be enabled in production for API consumers
springdoc.api-docs.enabled=true

# =============================================================================
# SERVER CONFIGURATION
# =============================================================================
# Embedded Tomcat server settings for HTTP request handling.

# HTTP port the application listens on
# Default: 8080
# Use 80 for production HTTP or 443 for HTTPS (requires SSL configuration)
# Set to 0 for random available port (useful for testing)
server.port=8080

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================
# Log level configuration by package/class. Available levels (in order):
#   TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
#
# For production, use INFO or WARN to reduce log volume.
# For development/debugging, use DEBUG or TRACE for detailed output.

# Spring Security logging
# DEBUG level logs authentication attempts, authorization decisions, and
# security filter chain processing. Useful for troubleshooting auth issues.
# WARNING: May expose sensitive information - use INFO in production
logging.level.org.springframework.security=DEBUG

# Application-specific logging
# Controls log output for the main application package
logging.level.org.automatize.status=DEBUG

# =============================================================================
# BUILD INFORMATION
# =============================================================================
# Application metadata populated at build time by Maven resource filtering.
# These values are displayed in the UI footer and API responses.

# Build timestamp
# The @timestamp@ placeholder is replaced by Maven during the build process
# with the actual build date/time
app.build.date=@timestamp@

# Copyright notice
# Displayed in application footer and API metadata
app.copyright=(c) A4IT BV & AUTOMATIZE BV - Developed by Tim De Smedt

# =============================================================================
# USER REGISTRATION
# =============================================================================
# Controls whether new users can self-register through the registration form.

# Enable/disable user registration
# When 'true':  Registration form is accessible, new accounts can be created
# When 'false': Registration is disabled, only admins can create users
# Useful for private deployments or after initial user setup
app.registration.enabled=true

# =============================================================================
# HEALTH CHECK SCHEDULER
# =============================================================================
# Configuration for the automated health check system that monitors
# application and component uptime. The scheduler periodically checks
# configured endpoints and records their availability status.

# Global health check toggle
# When 'true':  Health checks run automatically on schedule
# When 'false': All automated health checks are disabled
health-check.enabled=true

# Scheduler polling interval in milliseconds
# How often the scheduler checks for health checks that need to run
# Current value: 10000ms = 10 seconds
# Lower values = more responsive but higher CPU usage
# Recommended range: 5000-60000 (5 seconds to 1 minute)
health-check.scheduler-interval-ms=10000

# Default check interval for new health checks (in seconds)
# How often each individual health check runs by default
# Current value: 60 seconds = 1 minute
# Can be overridden per health check in the database
# Recommended: 30-300 seconds depending on criticality
health-check.default-interval-seconds=60

# Default HTTP timeout for health checks (in seconds)
# How long to wait for a response before marking check as failed
# Current value: 10 seconds
# Should be less than the check interval to prevent overlap
# Recommended: 5-30 seconds depending on target service
health-check.default-timeout-seconds=10

# Thread pool size for concurrent health checks
# Number of health checks that can run simultaneously
# Current value: 10 threads
# Increase for large numbers of monitored services
# Recommended: Number of monitored services / 10, minimum 5
health-check.thread-pool-size=10

# =============================================================================
# DATA INITIALIZATION
# =============================================================================
# Controls whether the DataInitializer runs on application startup.
# The DataInitializer creates a default tenant, organization, and admin user
# if they don't exist.

# Enable/disable data initialization
# When 'true':  Creates default admin account on first startup
# When 'false': Skips data initialization (recommended after first successful run)
# SECURITY: Set to 'false' in production after the initial admin account is created
# Default credentials: username=admin, password=admin
data.initializer.enabled=true

# =============================================================================
# EMAIL CONFIGURATION
# =============================================================================
# SMTP email settings for sending notifications, alerts, and user
# communications (password reset, registration confirmation, etc.)

# Email feature toggle
# When 'true':  Emails are sent via configured SMTP server
# When 'false': Email sending is disabled (logs email content instead)
# Set to 'false' for local development without email server
app.email.enabled=false

# SMTP server hostname
# Examples:
#   - Gmail: smtp.gmail.com
#   - Outlook: smtp-mail.outlook.com
#   - Amazon SES: email-smtp.{region}.amazonaws.com
#   - Custom: your-mail-server.example.com
spring.mail.host=smtp.example.com

# SMTP server port
# Common ports:
#   - 25:   Standard SMTP (often blocked by ISPs)
#   - 465:  SMTP over SSL (SMTPS)
#   - 587:  SMTP with STARTTLS (recommended)
#   - 2525: Alternative port (some cloud providers)
spring.mail.port=587

# SMTP authentication credentials
# The email address used as the sender (From address)
# WARNING: In production, use environment variables or secrets manager
spring.mail.username=noreply@example.com
spring.mail.password=your-password-here

# SMTP authentication requirement
# When 'true', username and password are required for SMTP connection
spring.mail.properties.mail.smtp.auth=true

# STARTTLS encryption settings
# STARTTLS upgrades a plain connection to encrypted
# 'enable':   Attempt STARTTLS if server supports it
# 'required': Fail if STARTTLS is not available (recommended for security)
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
